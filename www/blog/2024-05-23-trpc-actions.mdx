---
slug: trpc-actions
title: Using Server Actions with tRPC
author: Julius Marminge
author_title: tRPC Core Team Member
author_url: https://twitter.com/jullerino
author_image_url: https://github.com/juliusmarminge.png
---

import { InstallSnippet } from '@site/src/components/InstallSnippet';
import { Tweet } from 'react-tweet';

The new builder API introduced in tRPC v10 has been massively appreciated by the community, and many libraries have adopted similar patterns.
There's even been coined a term `tRPC like XYZ` as evidence of the growing popularity of this pattern. In fact, just yesterday I saw [someone
wondering if there was a way to write CLI applications with a similar API to tRPC](https://x.com/localhost_5173/status/1793259910723215835).
Sidenote, you can even use [tRPC directly to do this](https://github.com/mmkal/trpc-cli). But that's not what we're here to talk about today,
we're going to talk about how to use tRPC with server actions from Next.js.

## What's a server action?

In case you live under a rock and haven't kept up with the latest React and Next.js features, server actions allows you to write regular functions that are executed on the server, import them on the client and call them just as if they were regular functions.
You may think that this sounds similar to tRPC which is true. According to Dan Abramov, server actions are tRPC as a bundler feature:

<div className="mb-4 flex w-full justify-center">
  <Tweet id="1756120297529368801" />
</div>

And this is totally accurate, server actions are, similar to tRPC, at the end of the day an RPC technology. Both allows you to write functions on the backend and call them with full typesafety on the frontend with the network layer abstracted away.

So where does tRPC come in? Why do I need both tRPC and server actions? Server actions is a primitive, and as for all primitives they're lacking some fundamental aspects when it comes to building APIs. For any API endpoint that is exposed over internet, you need to validate and authorize requests to ensure your API is not used maliciously. As previously mentioned, tRPC's API is appreciated by the community, so wouldn't it be nice if we could use tRPC to define server actions and utilizing all the awesome features that comes built-in with tRPC such as input validation, authentication and authorization through middlewares, output validation, data transformers, etc, etc. I think so, so let's dig in.

## Defining server actions with tRPC

:::note
**Prerequisites:** In order to use server actions, you need to use the Next.js App Router. Additionally, all the tRPC stuff we'll use are only available on tRPC v11, so make sure you're using the beta release channel of tRPC:

<InstallSnippet pkgs="@trpc/server@beta" />
:::

Let's start off by initializing tRPC and defining our base server actions procedure.
We'll use the `experimental_caller` method on the procedure builder, which is a new method that allows you to
customize the way that the procedure is called when it's invoked as a function. We'll also use the adapter `experimental_nextAppDirCaller`
to make it compatible with Next.js. This adapter will handle cases where the server action is wrapped in `useActionState` on the client,
which [changes the call signature of the server action](https://react.dev/reference/react/useActionState#my-action-can-no-longer-read-the-submitted-form-data).

We'll also be using a `span` property as [metadata](/docs/server/metadata), since there is no ordinary path like when you use a router (`user.byId` for example). You can use the span property to differentiate procedures, for example during logging or observability.

```ts title="server/trpc.ts"
import { initTRPC, TRPCError } from '@trpc/server';
import { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';

interface Meta {
  span: string;
}

export const t = initTRPC.meta<Meta>().create();

const serverActionProcedure = t.procedure.experimental_caller(async (opts) => {
  const path = (opts._def.meta as Meta | undefined)?.span;
  if (path) opts._def.path = path;
  return experimental_nextAppDirCaller(opts);
});
```

Next, we'll add some [context](/docs/server/context). Since we wont be hosting a router using a regular adapter, we won't have any context injected through the `createContext`
method on the adapter. Instead, we'll use a middleware to inject context. In this example, let's retrieve the current user from the session, and inject it into the context.

```ts title="server/trpc.ts"
import { initTRPC, TRPCError } from '@trpc/server';
import { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';
import { currentUser } from '~/auth';

interface Meta {
  span: string;
}

export const t = initTRPC.meta<Meta>().create();

export const serverActionProcedure = t.procedure
  .experimental_caller(async (opts) => {
    const path = (opts._def.meta as Meta | undefined)?.span;
    if (path) opts._def.path = path;
    return experimental_nextAppDirCaller(opts);
  })
  .use(async (opts) => {
    // Inject user into context
    const user = await currentUser();
    return opts.next({ ctx: { user } });
  });
```

Lastly, we'll create a `protectedAction` procedure that will protect any action from unauthenticated users. If you have an existing middleware that does this you can use that, but I'll define one in-line for this example.

```ts title="server/trpc.ts"
import { initTRPC, TRPCError } from '@trpc/server';
import { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';
import { currentUser } from '~/auth';

interface Meta {
  span: string;
}

export const t = initTRPC.meta<Meta>().create();

export const serverActionProcedure = t.procedure
  .experimental_caller(async (opts) => {
    const path = (opts._def.meta as Meta | undefined)?.span;
    if (path) opts._def.path = path;
    return experimental_nextAppDirCaller(opts);
  })
  .use(async (opts) => {
    // Inject user into context
    const user = await currentUser();
    return opts.next({ ctx: { user } });
  });

export const protectedAction = serverActionProcedure.use((opts) => {
  if (!opts.ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
    });
  }

  return opts.next({
    ctx: {
      ...opts.ctx,
      user, // <-- ensures type is non-nullable
    },
  });
});
```

Alright, let's write an actual server action. Create an `_actions.ts` file, decorate it with the `"use server"` directive, and define your action.

```ts title="app/_actions.ts"
'use server';

import { protectedAction } from '~/server/trpc';
import { z } from 'zod';

export const createPost = protectedAction
  .input(
    z.object({
      title: z.string(),
    }),
  )
  .mutation(async ({ ctx, input }) => {
    // Do something with the input
  });
```

Wow, it's that easy to define a server action that's protected from unauthenticated users, with input validation to protect against attacks such as SQL injections. Let's import this function on the client and call it.

```tsx title="app/post-form.tsx"
'use client';

import { createPost } from '~/_actions';

export function PostForm() {
    return (
        <form
            // Use `action` to make form progressively enhanced
            action={createPost}
            // `Using `onSubmit` allows building rich interactive
            // forms once JavaScript has loaded
            onSubmit={async (e) => {
                e.preventDefault();
                const title = new FormData(e.target).get('title');
                // Maybe show loading toast, etc etc. Endless possibilities
                await createPost({ title });
            }}
        >
            <input type="text" name="title" />
            <button type="submit">Create Post</button>
        </form>
    )
}
```
