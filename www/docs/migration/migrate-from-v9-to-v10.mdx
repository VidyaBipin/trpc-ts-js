---
id: migrate-from-v9-to-v10
title: Migrate from v9 to v10
sidebar_label: Migrate from v9 to v10
slug: /migrate-from-v9-to-v10
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

```ts
// v9
const legacyRouter = trpc.router().query('greeting', {
  input: z.string(),
  resolve({ input }) {
    return `hello ${input}!`;
  },
});

// v10
const appRouter = t.router({
  greeting: t.procedure
    .input(z.string())
    .query(({ input }) => `hello ${input}!`),
});
```

Welcome to tRPC v10! We're excited to bring you a new major version to continue the journey towards perfect end-to-end type safety with excellent DX.

Under the hood, we are unlocking performance improvements, bringing quality of life enhancements, and creating room for us to build new features in the future.

tRPC v10 features a compatibility layer for users coming from v9. The `.interop()` method allows you to incrementally adopt v10 so that you can continue building the rest of your project while still enjoying v10's new features.

:::caution
There are [a few features that are not supported by `.interop()`](#limitations-of-interop). We expect nearly all of our users to be able to use `.interop()` to migrate their server side code in only a few minutes. If you are discovering that `.interop()` is not working correctly for you, be sure to [check here](#limitations-of-interop).
:::caution

## Enabling `interop()` on a v9 router

Turning your v9 router into a v10 router only takes 10 characters. Add `.interop()` to the end of your v9 router...and you're done with your server code!

```ts title="/server.ts"
import * as trpc from '@trpc/server';

const appRouter = trpc.router().interop();

export type AppRouter = typeof appRouter;
```

You will now need to [visit your client code to update your callers to the v10 syntax](#client-package-changes).

## Merging a v9 router into a v10 router

You may also choose to start writing new procedures using the v10 syntax - but keep your v9 procedures in place for now. Incremental adoption is only a matter of merging the two routers together.

To merge a v9 router into a v10 router, you'll need to keep the `.interop()` method on your v9 router and write a little glue code using the `.mergeRouters()` method introduced in v10.

We will create a simple `hello world` v10 router to demonstrate interoperability mode. If you have not learned how to create a more complex tRPC v10 router yet, we encourage you to check out the rest of the documentation.

```ts title="/server.ts"
import { initTRPC } from '@trpc/server';
import { legacyRouter } from './legacyRouter.ts';

export const t = initTRPC()();

const v10Router = t.router({
  greeting: t.procedure
    .input(z.string())
    .query(({ input }) => `hello ${input}!`),
});

export const appRouter = t.mergeRouters(v10Router, legacyRouter);
```

:::warning
Be careful of using procedures that will end up having the same caller name! You will run into issues if a path in your legacy router matches a path in your new router.
:::warning

Both sets of procedures will now be available for your client. You will now need to [visit your client code to update your callers to the v10 syntax](#client-package-changes).

## Limitations of `.interop()`

### Subscriptions

ðŸš§

### Custom [Links](links)

ðŸš§

## Client Package Changes

v10 also brings changes to the client side of your application. After making a few key changes, you'll unlock a few key quality of life changes:

- Jump to server definitions straight from your client
- TODO
- TODO

### `@trpc/react`

#### Major version upgrade of `react-query`

We've upgraded `peerDependencies` from `react-query@^3` to `@tanstack/react-query@^4`. Because our client hooks are only a thin wrapper around `react-query`, we encourage you to [visit their migration guide](https://tanstack.com/query/v4/docs/guides/migrating-to-react-query-4) for more details around your new React hooks implementation.

#### tRPC-specific options on hooks moved to `trpc` property

To avoid collisions and confusion with any built-in `react-query` properties, we have moved all of the tRPC options to a property called `trpc`. This namespace brings clarity to options that are tRPC specific and ensures that we won't collide with `react-query` in the future.

```tsx
// Before
useQuery(['post.byId', '1'], {
  context: {
    batching: false,
  },
});

// After
useQuery(['post.byId', '1'], {
  trpc: {
    context: {
      batching: false,
    },
  },
});
```

### `@trpc/next`

#### `setupNext()` - Optional DX Improvement

Setting up tRPC for Next.js is now much easier. `@trpc/next` now includes a `setupTRPC` export that scaffolds tRPC for your Next.js application. We've seen how our v9 + Next.js users most commonly use tRPC and used those for sensible defaults (including server-side rendering).

In tRPC v9, setting up a Next.js application took [a good bit of configuring](/docs/v9/nextjs). But now, v10 allows us to set up our `_app.tsx` wrapper and data fetching hooks from just one export.

```ts title="utils/trpc.ts"
// Import the types for your backend router
import { setupTRPC } from '@trpc/next';
import type { AppRouter } from 'routers/_app';

export const trpc = setupTRPC<AppRouter>({
  config() {
    return {
      url: '/api/trpc',
    };
  },
});
```

```tsx title="pages/_app.tsx"
// Same import as component file below!
import { trpc } from '../utils/trpc';

const MyApp = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);
```

```tsx title="components/avatar.tsx"
// Same import as app file above!
import { trpc } from '../utils/trpc';

const JsonPrettyPrinter = () => {
  const { isError, isLoading, data } = trpc.proxy.getSomeJson.useQuery();

  if (isError) return <p>Uh oh.</p>
  if (isLoading) return <p>Loading...</p>

  return <pre>{ JSON.stringify(data, null, 2) }<pre>
};
```

### `@trpc/client`

#### Aborting procedures

[The `AbortController` Web API](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) allows clients to cancel their web requests using the `.abort()` method.

Previously, we had a `.cancel()` method that was a part of the tRPC implementation. We have deprecated this method in favor of `AbortController` and its `.abort()` method. The goal here is to use native Web API implementations where possible.

```tsx
const ac = new AbortController();
const postQuery = proxy.postById.query('postId123', { signal: ac.signal });

// Aborting
ac.abort();
```
