---
id: anatomy-of-trpc
title: Anatomy of tRPC
sidebar_label: Anatomy of tRPC
slug: /anatomy-of-trpc
---

import { ArticleCard } from '../../src/components/ArticleCard';

## Introduction

The goal of this page is to give you a high-level overview of how tRPC works. It's not meant to be a tutorial or a guide. If you're looking for that, check out the [Quickstart](./quickstart.mdx).

If you would prefer to see this in video form, check out the ["How tRPC really works"](https://www.youtube.com/watch?v=x4mu-jOiA0Q) video. This video uses Next.js so the file structure might differ from that in your project, but the concepts are the same for any framework.

The anatomy of tRPC can be seen in the following diagram. We will start at the bottom with a query or mutation made by the client, and work our way over the network boundary and through tRPC's internals until the procedure is handled and a response is sent. Finally we will see how the client can know about the shape of the backend.

<img
  className="max-h-screen rounded-xl"
  alt="Diagram of a tRPC procedure"
  src="https://user-images.githubusercontent.com/8353666/230760330-20ac7910-ba80-4743-92e5-2df699229b0e.png"
/>

TODO: signpost to "main" docs as much as possible

## Client

- query / mutation
  - the client's way of calling a procedure
  - mention RQ hooks
- links
  - determines how the client talks to the server
  - most applications never need to touch this after initial setup
- transformers (here or in adapter?)
  - serializes and deserializes the data sent over the wire (e.g. JSON.stringify, but we have some better ones)
  - most common example: superjson allows sending dates etc over the wire

## Server

- adapter
  - the glue between your backend and trpc
  - takes a router and context
  - Transformers => here or in client?
- context
  - "stuff that every procedure has access to"
  - outer/inner context
- meta
  - an object of information about the procedure
  - use cases
    - allows you to know information about the procedure in middleware
    - generating OpenAPI spec with OpenAPI
    - not required!
- router
  - groups a set of procedures and other routers under a shared namespace, which determines how the URL is constructed and the procedure is called from the frontend.
  - `example.com/api/trpc/someRouter.someSubRouter.someProcedure`, the router determines the `someRouter.someProcedure` part. It also determines that the procedure exists at `trpc.someRouter.someSubRouter` in the frontend.
- middleware (before or after procedure?)
  - Runs before and after a procedure
  - Can be used to add logging, authentication, etc.
  - Can modify context, and the new context type is inferred in the procedure
  - FILO - the last middleware that runs before the procedure is the first that runs after it
- procedure
  - can be a query or mutation
  - should subscriptions be mentioned here?
  - error handling?

## Type magic

TODO: better name for section?

- app router type exported in BE
- this is importend in FE where the client is created
- client gets this + a url of where the backend lives
- client can now know about the shape of the backend

## Learn more

:::info

You don't need to know this to use tRPC. It's only for people who are curious about how tRPC works under the hood.

:::

### Tiny RPC

In this article, tRPC Core Team member Julius Marminge walks you through creating a minimal version of tRPC from scratch. It's a great way to learn more about how tRPC works internally. You'll learn about proxies, advanced TypeScript, and more.

<ArticleCard
  title="Writing a tiny tRPC client"
  link="/blog/tinyrpc-client"
  date={new Date('2023-01-17')}
  author={{
    name: 'Julius Marminge',
    description: 'tRPC Core Team Member',
    avatar: 'https://github.com/juliusmarminge.png',
    link: 'https://github.com/juliusmarminge',
  }}
/>
